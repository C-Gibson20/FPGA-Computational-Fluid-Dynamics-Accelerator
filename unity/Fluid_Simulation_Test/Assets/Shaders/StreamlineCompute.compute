#pragma kernel StreamlineCompute

cbuffer SimulationParams
{
    float2 _TexSize;
    float2 _InvTexSize;
    float _DeltaTime;
    uint _ParticleCount;
    uint _TrailLength;
}

Texture2D<float4> _VelocityTex;
SamplerState sampler_linear_clamp;

RWStructuredBuffer<float2> _Particles;
RWStructuredBuffer<float2> _Trails;
RWStructuredBuffer<uint> _HeadIndices;

[numthreads(64, 1, 1)]
void StreamlineCompute(uint3 tid : SV_DispatchThreadID)
{
    uint id = tid.x;
    if (id >= _ParticleCount)
        return;

    // —— Advect ——
    float2 pos = _Particles[id];
    float2 v0 = _VelocityTex.SampleLevel(sampler_linear_clamp, pos * _InvTexSize, 0).xy;
    float2 midPos = pos + 0.5 * v0 * _DeltaTime;
    float2 v1 = _VelocityTex.SampleLevel(sampler_linear_clamp, midPos * _InvTexSize, 0).xy;
    float2 newPos = pos + v1 * _DeltaTime;

    // —— Wrap around ——
    newPos = (newPos < 0) ? newPos + _TexSize : newPos;
    newPos = (newPos >= _TexSize) ? newPos - _TexSize : newPos;
    _Particles[id] = newPos;

    // —— Circular buffer ——
    uint head = _HeadIndices[id]; 
    uint writeIdx = id * _TrailLength + head; // linear index into _Trails
    _Trails[writeIdx] = newPos; // overwrite oldest

    // -- Advance and wrap head --

    head = head + 1;
    if (head >= _TrailLength)
        head = 0;
    _HeadIndices[id] = head;
}