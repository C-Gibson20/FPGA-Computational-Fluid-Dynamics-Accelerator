## 22 May 2025
Went over the research provided by my team and started implementing an LBM solver in verilog. Currently have only added the RAM and some basic setup to the top level file, however made a few key discoveries about the memory. The PYNQ has 140 blocks of 36 Kbit block ram, which leaves us with 5.04 Mbits of BRAM. This means we can't store each cell as it's own RAM as we are limited to a total of 140 blocks, it also means our resolution is limited by our BRAM. We are currently using the lattice boltzmann method with 9 directions per cell, also known as D2Q9, along with 16 bit fixed point words. This means our total memory usage is given by the following:
$$resolution*9*16 = memory$$
$$\therefore resolution<\frac{5.04*10^6}{144} = 35000$$
There are methods to decrease our memory usage by only using chunks of memory at a time, however for now we will stick with the straightforward method of just intializing 9 blocks of RAM, one for each direction.
## 23 May 2025
Implemented the streaming stage, in our implementation we assume the boundaries of the simulation simply absorb the particles, so my code reflects that by not writing anything when a cell points to a boundary. The code is currently in system verilog and needs to be translated over to verilog, it's mostly converted now I just need to change all the logic signals to reg and wires. Also found an equation of the framerate as a function of the clock frequency and the number of cycles used to calculate each cell. Our resolution is 300*100, we want the frequency to be 50Mhz, and the framerate to be at least 60.

$$(\frac{frequency}{cycles\ per\ cell*resolution}) = framerate$$
$$\therefore cycles\ per\ cell < \frac{50*10^6}{60*30000} = 27.8 $$

## 26 May 2025
Implemented bouncing stage and started to implement collision stage. For the bouncing stage we have an input signal of barriers which has the same number of bits as depth. If a bit in the barrier signal is one then at that index there is a barrier. In the case of a barrier we push all the vectors out of the cell and reflect them back to where they came from, this is simply done by swapping the data out for the next stage of the cycle with the opposite side's data in. We then loop through the cells one more time and any barrier cells have all their densities set to 0. Now for the streaming and bouncing phases the **number of cycles per cell is 5**, 2 for streaming (read then write) and 3 for bouncing (read, write, set barrier cells to 0). Meaning according to our earlier calculation I have 22 cycles left for the collision phase in order to meet 60 fps. I will make use of these as multiplies are expensive, so the best way to deal with them is pipelining, meaning I will use more cycles per cell, but I will reduce the critical path.

## 27th May - 2nd June 2025
Completed unit testing of the streaming and bouncing stage and implemented the collision state machine. Nishant and Jeremy took over doing the actual code for the collider which calculates the required values. Needed to implement some pratical considerations into my design, such as the fact that our RAMs on FPGA take in only one address and the 2 cycle delay for reading from the RAM. The rest of the time was spent preparing slides for the interim presentation with my group

## 4th June 2025
Started implementing some parallelization into the LBMSolver module. The way we have decided to carry it out is by reading values for multiple indexes from the RAM at once, the BRAMs on our FPGA can have a bitwidth of up to 128 bits, so at most we can read from 8 cells at a time since our data width is 16 bits. The initial design I have decided to go with adds an extra module called LBMController. LBMController will be connecting to the RAMs instead of the LBMSolvers and it will split/combine the data coming from/going to the RAMs as necessary. Additionally it will control the index and state of the LBMSolvers, this keeps the solvers in sync with each other. The LBMSolver module also needs to be modified as it's state and index is no longer independent of other components. The main parts that have to be rewritten are the "next" variables, this includes next_index, next_write_enable, etc... and the state machine. We now use the "next" variables as outputs that are fed into the LBMController so it can determine what should be written into the RAMs. The state machine also needs rewriting I believe it's better to move state transitions over to the LBMController module and simply leave the outputs to be determined by the LBMSolver, in my intial rewrite I tried to keep the state transitions within LBMSolver, but this caused issues as there are cases where two LBMSolvers might want to enter different statesm e.g. in the stream state the index of one solver might be past the frame, so it wants to move to the bounce state, but other solvers might not have indexed past the frame.